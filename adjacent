#!/usr/bin/env python3

from __future__ import print_function

import re

def printed_width(s):
  chars = 0
  i = 0
  while i < len(s):
    c = s[i]
    if c == '\x1b':
      m = re.search("""\[[0-9]+(;[0-9]+)?m""", s[i+1:])
      if m:
        i += 1+len(m.group(0))
        continue
    i += 1
    chars += 1
  return chars

def pad_to(s, w):
  return s + " " * (w - printed_width(s))

if __name__ == "__main__":
  import argparse
  import itertools

  parser = argparse.ArgumentParser(
    formatter_class=argparse.ArgumentDefaultsHelpFormatter)
  parser.add_argument('-w', '--width',
                      default=0,
                      help="total width to aim for (0 to use first file)")
  parser.add_argument('--sep',
                      default="",
                      help="column separator string")
  parser.add_argument("file1", type=argparse.FileType())
  parser.add_argument("file2", type=argparse.FileType())

  args = parser.parse_args()

  # compute file1 width
  width = args.width//2
  if width == 0:
    # materialize file1 since we'll read it twice
    args.file1 = args.file1.readlines()
    width = max([printed_width(l) for l in args.file1])

  for l1, l2 in itertools.zip_longest(args.file1, args.file2, fillvalue='\n'):
    l1 = l1.rstrip('\n')
    print(pad_to(l1, width), l2, sep=args.sep, end="")
